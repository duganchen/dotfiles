#!/usr/bin/env python3

import argparse


# Picking this format mainly because it's part of the standard library.
import json

import os
import pathlib
import sys


def main():
    parser = argparse.ArgumentParser(prog="dirmark", description="directory bookmarker")
    subparsers = parser.add_subparsers(required=True)
    add_parser = subparsers.add_parser("add")
    add_parser.set_defaults(func=add_bookmark)
    add_parser.add_argument("directory", type=existing_dir)
    add_parser.add_argument("bookmarks", type=pathlib.Path)

    delete_parser = subparsers.add_parser("delete")
    delete_parser.set_defaults(func=delete_bookmark)
    delete_parser.add_argument("directory")
    delete_parser.add_argument("bookmarks", type=pathlib.Path)

    clear_parser = subparsers.add_parser("clear")
    clear_parser.set_defaults(func=clear_bookmarks)
    clear_parser.add_argument("bookmarks", type=pathlib.Path)

    list_parser = subparsers.add_parser("list")
    list_parser.set_defaults(func=list_bookmarks)
    list_parser.add_argument("current_dir", type=existing_dir)
    list_parser.add_argument("bookmarks", type=pathlib.Path)

    listall_parser = subparsers.add_parser("listall")
    listall_parser.set_defaults(func=listall_bookmarks)
    listall_parser.add_argument("bookmarks", type=pathlib.Path)

    args = parser.parse_args()
    args.func(args)

# Note that most of these just do nothing if the specified bookmarks file
# does not exist. This is a deliberate choice, and correct for what I'm integrating
# this with.

def existing_dir(directory: str) -> str:
    if not os.path.isdir(directory):
        raise argparse.ArgumentTypeError()
    return str(pathlib.Path(directory).resolve())


def add_bookmark(args):
    # This is the format.
    bm = {"bookmarks": []}
    if args.bookmarks.is_file():
        with open(args.bookmarks) as f:
            bm = json.load(f)

    bookmarks = [args.directory]

    for bookmark in bm["bookmarks"]:
        if os.path.isdir(bookmark) and bookmark != args.directory:
            bookmarks.append(bookmark)

    bm["bookmarks"] = bookmarks

    with open(args.bookmarks, "w") as f:
        json.dump(bm, f, indent=4)


def delete_bookmark(args):
    bm = {"bookmarks": []}
    if args.bookmarks.is_file():
        with open(args.bookmarks) as f:
            bm = json.load(f)

    bm["bookmarks"] = [x for x in bm["bookmarks"] if x != args.directory]

    with open(args.bookmarks, "w") as f:
        json.dump(bm, f, indent=4)


def clear_bookmarks(args):
    with open(args.bookmarks, "w") as f:
        json.dump({"bookmarks": []}, f, indent=4)


# This is meant to be piped into FZF
def list_bookmarks(args):
    if (os.path.isfile(args.bookmarks)):
        with open(args.bookmarks) as f:
            bookmarks = json.load(f)
            for bookmark in bookmarks["bookmarks"]:
                if bookmark != args.current_dir:
                    print(bookmark)


# This is meant to be seen directly by the user.
def listall_bookmarks(args):
    if args.bookmarks.is_file():
        with open(args.bookmarks) as f:
            bookmarks = json.load(f)
            for bookmark in bookmarks["bookmarks"]:
                print(bookmark)


if __name__ == "__main__":
    main()
